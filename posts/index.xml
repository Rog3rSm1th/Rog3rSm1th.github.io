<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Rog3rSm1th</title>
        <link>https://Rog3rSm1th.github.io/posts/</link>
        <description>Recent content in Posts on Rog3rSm1th</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 18 Mar 2022 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://Rog3rSm1th.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Fuzzing Pillow with Frelatage to find bugs and vulnerabilities</title>
            <link>https://Rog3rSm1th.github.io/posts/fuzzing-python-libraries-frelatage/</link>
            <pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate>
            
            <guid>https://Rog3rSm1th.github.io/posts/fuzzing-python-libraries-frelatage/</guid>
            <description>What is fuzzing?  Fuzzing or fuzz testing is an effective way of finding bugs or vulnerabilities in a software or a library. The program which is used to fuzz is called the fuzzer (for example: AFL, HongFuzz or wfuzz) and the program being fuzzed is our target. A fuzzer typically starts feeding the target program with random inputs while observing its behaviour. Whenever the target crashes, the fuzzer reports the input which caused the crash to the user as a bug or a crash.</description>
            <content type="html"><![CDATA[<h2 id="what-is-fuzzing">What is fuzzing?</h2>
<blockquote>
<p><em>Fuzzing</em> or <em>fuzz testing</em> is an effective way of finding bugs or vulnerabilities in a software or a library. The program which is used to fuzz is called the fuzzer (for example: <a href="https://github.com/google/AFL">AFL</a>, <a href="https://github.com/google/honggfuzz">HongFuzz</a> or <a href="https://github.com/xmendez/wfuzz">wfuzz</a>) and the program being fuzzed is our target. A fuzzer typically starts feeding the target program with random inputs while observing its behaviour. Whenever the target crashes, the fuzzer reports the input which caused the crash to the user as a bug or a crash.</p>
</blockquote>
<p>This method has proven its value many times in vulnerabilities and bugs research, as shown in these different articles and videos:</p>
<ul>
<li><a href="https://blog.cloudflare.com/a-gentle-introduction-to-linux-kernel-fuzzing/">Fuzzing the linux kernel with AFL++</a></li>
<li><a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">Pulling JPEGs out of thin air</a> (THE article that made me interested in fuzzing)</li>
<li><a href="https://www.youtube.com/watch?v=IOTTqRT8tf0">Fuzzing Google V8 JavaScript Engine with Dharma </a></li>
<li><a href="https://bananamafia.dev/post/gb-fuzz/">Fuzzing A GameBoy Emulator With AFL++</a></li>
</ul>
<p>So a few weeks ago, I immersed myself  into this new world, and after spending a lot of time playing with AFL++, HongFuzz and Atheris on a lot of programs, I felt like writing my own fuzzer, first for learning purposes, then for finding vulnerabilities. A few nights of code later, Frelatage was born.</p>
<h2 id="frelatage">Frelatage</h2>
<p>Frelatage is a coverage-based Python fuzzing library which can be used to fuzz python code.</p>
<p>-&gt; It is a <strong>mutation-based</strong> fuzzer. Meaning, Frelatage generates new inputs by slightly modifying a seed input, using different method such as duplicating a part of the input, or modifying a segment of it.</p>
<p>-&gt; Frelatage is also a <strong>greybox fuzzer</strong> (not blackbox nor whitebox). Meaning, Frelatage leverages coverage-feedback to learn how to reach deeper into the program. It is not entirely blackbox because Frelatage leverages at least some program analysis. It is not entirely whitebox either because Frelatage does not build on heavyweight program analysis or constraint solving. Instead, Frelatage uses lightweight program instrumentation to glean some information about the <strong>coverage</strong> of a generated input. If a generated input increases coverage, it is used afterwards  for further fuzzing.</p>
<h4 id="influences">Influences</h4>
<p>The development of Frelatage was inspired by various other fuzzers, including <em>AFL/AFL++</em>, <em>Atheris</em> and <em>PythonFuzz</em>.The main purpose of the project is to take advantage of the best features of these fuzzers and gather them together into a new tool in order to efficiently fuzz python applications and libraries.</p>
<ol>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#setting-up-our-fuzzing-environment">Setting up our fuzzing environment</a>
<ol>
<li><a href="#installing-frelatage">Installing Frelatage</a></li>
<li><a href="#creation-of-a-corpus">Creation of a corpus</a></li>
<li><a href="#dictionary-based-optimization">Dictionary-based optimization</a></li>
</ol>
</li>
<li><a href="#writing-the-fuzzing-harness">Writing the fuzzing harness</a></li>
<li><a href="#running-the-fuzzer">Running the fuzzer</a></li>
<li><a href="#triaging-the-crashes-reports">Triaging the crashes reports</a></li>
<li><a href="#upcoming-features">Upcoming features</a></li>
</ol>
<h2 id="how-it-works">How it works</h2>
<p>The idea behind the design of Frelatage is the usage of a <em>genetic algorithm</em> to generate mutations that will cover as much code as possible (frelatage is a <strong>coverage-based fuzzer</strong>). The process of a fuzzing cycle can be roughly summarized with this diagram:</p>
<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'center'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
graph TB

    m1(Mutation 1) --> |input| function(Fuzzed function)
    m2(Mutation 2) --> |input| function(Fuzzed function)
    mplus(Mutation ...) --> |input| function(Fuzzed function)
    mn(Mutation n) --> |input| function(Fuzzed function)
    
    function --> generate_reports(Generate reports)
    generate_reports --> rank_reports(Rank reports)  
    rank_reports --> select(Select n best reports)
    
    select --> |mutate| nm1(Mutation 1) & nm2(Mutation 2) & nmplus(Mutation ...) & nmn(Mutation n)
    
    subgraph Cycle mutations
    direction LR
    m1
    m2
    mplus
    mn
    end
    
    subgraph Next cycle mutations
    direction LR
    nm1
    nm2
    nmplus
    nmn
    end
     
    style function fill:#5388e8,stroke:white,stroke-width:4px

  </div>
<h2 id="setting-up-our-fuzzing-environment">Setting up our fuzzing environment</h2>
<h4 id="installing-frelatage">Installing Frelatage</h4>
<p>The package is available on <a href="https://pypi.org/project/frelatage/">PyPi</a> and can be installed simply with pip:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">pip3 install frelatage
</code></pre></div><h4 id="the-project-structure">The project structure</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Create the main folder</span>
mkdir pillow_fuzz
cd pillow_fuzz

<span style="color:#75715e"># Create the input file folder</span>
mkdir in
<span style="color:#75715e"># Create the dictionary folder</span>
mkdir dict
<span style="color:#75715e"># Create the fuzzing harness file</span>
touch pillow_fuzzer.py
</code></pre></div><p>Once these operations are done, we have a tree structure of this form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">  â”œâ”€â”€ pillow_fuzzer.py
  â”‚   â”œâ”€â”€ dict
  â”‚   â”œâ”€â”€ in
</code></pre></div><h2 id="creation-of-a-corpus">Creation of a corpus</h2>
<blockquote>
<p>A corpus is a set of inputs for a fuzz target. In most contexts, it refers to a set of minimal test inputs that generate maximal code coverage.</p>
</blockquote>
<p>Pillow being an image processing library, we will need a corpus of images to reach a satisfactory code coverage and help the fuzzer to find interesting paths. The <a href="https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html">official documentation</a> of the library informs us that the following formats are fully supported:</p>
<ul>
<li>BMP</li>
<li>DDS</li>
<li>DIB</li>
<li>EPS</li>
<li>GIF</li>
<li>ICNS</li>
<li>ICO</li>
<li>IM</li>
<li>JPEG</li>
<li>JPEG 2000</li>
<li>MSP</li>
<li>PCX</li>
<li>PNG</li>
<li>Saving</li>
<li>PPM</li>
<li>SGI</li>
<li>SPIDER</li>
<li>TGA</li>
<li>TIFF</li>
<li>WebP</li>
<li>XBM</li>
</ul>
<p>In order to optimize the efficiency of the fuzzer, it may be relevant to write a different fuzzing harness for each supported format. This includes the creation of a dictionary specific to each format, as well as a dedicated corpus for each fuzzing harness.</p>
<blockquote>
<p>What we call a <strong>fuzzing harness</strong> is a test case or a particular test target.</p>
</blockquote>
<p>For this article, we will focus on the <strong>JPEG</strong> format, on the one hand because it is one of the most widespread formats, and on the other hand because it is the format for which it is the easiest to find a corpus (with PNG and GIF).</p>
<p>There are already pre-made corpus freely available, for the needs of our work we will use this <a href="https://github.com/strongcourage/fuzzing-corpus/tree/master/jpg">one</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Download the corpus</span>
svn export https://github.com/strongcourage/fuzzing-corpus/trunk/jpg

<span style="color:#75715e"># Merge all subfolders into the ./in folder</span>
cp jpg/*/* ./in
rm -rf jpg
</code></pre></div><h2 id="dictionary-based-optimization">Dictionary-based optimization</h2>
<p>A JPEG image consists of a sequence of segments, each beginning with a marker, each of which begins with a 0xFF byte, followed by a byte indicating what kind of marker it is.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://d33wubrfki0l68.cloudfront.net/bdc1363abbd5744200ec5283d4154e55143df86c/8c624/images/decoding_jpeg/jpegrgb_dissected.png" alt="space-1.jpg"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">representation of a JPEG file</td>
</tr>
</tbody>
</table>
<p>We will use <a href="https://github.com/Rog3rSm1th/Frelatage/blob/main/dictionaries/jpeg.dict">this dictionary</a> that was written for AFL by Michal Zalewski.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">#
# AFL dictionary for JPEG images
# ------------------------------
#
# Created by Michal Zalewski
#

header_jfif=&#34;JFIF\x00&#34;
header_jfxx=&#34;JFXX\x00&#34;

section_ffc0=&#34;\xff\xc0&#34;
section_ffc2=&#34;\xff\xc2&#34;
section_ffc4=&#34;\xff\xc4&#34;
section_ffd0=&#34;\xff\xd0&#34;
section_ffd8=&#34;\xff\xd8&#34;
section_ffd9=&#34;\xff\xd9&#34;
section_ffda=&#34;\xff\xda&#34;
section_ffdb=&#34;\xff\xdb&#34;
section_ffdd=&#34;\xff\xdd&#34;
section_ffe0=&#34;\xff\xe0&#34;
section_ffe1=&#34;\xff\xe1&#34;
section_fffe=&#34;\xff\xfe&#34;
</code></pre></div><p>it will be saved in the <code>./dict</code> folder (default folder for dictionaries)</p>
<h2 id="writing-the-fuzzing-harness">Writing the fuzzing harness</h2>
<p>Our fuzzing harness will be in <code>pillow_fuzzer.py</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> frelatage
<span style="color:#f92672">from</span> PIL <span style="color:#f92672">import</span> Image
<span style="color:#f92672">from</span> PIL <span style="color:#f92672">import</span> ImageFile

<span style="color:#75715e"># Allow PIL to load truncated images</span>
ImageFile<span style="color:#f92672">.</span>LOAD_TRUNCATED_IMAGES <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>

<span style="color:#75715e"># The function we want to fuzz</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">jpeg_fuzz_pillow</span>(image):
    <span style="color:#75715e"># We fuzz the &#34;open&#34; method</span>
    Image<span style="color:#f92672">.</span>open(image)
    <span style="color:#66d9ef">return</span>

<span style="color:#75715e"># Load the corpus</span>
jpeg_corpus <span style="color:#f92672">=</span> frelatage<span style="color:#f92672">.</span>load_corpus(directory<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./&#34;</span>)
<span style="color:#75715e"># Initialize the fuzzer</span>
f <span style="color:#f92672">=</span> frelatage<span style="color:#f92672">.</span>Fuzzer(jpeg_fuzz_pillow, [jpeg_corpus])
<span style="color:#75715e"># Launch the fuzzing process</span>
f<span style="color:#f92672">.</span>fuzz()
</code></pre></div><h2 id="running-the-fuzzer">Running the fuzzer</h2>
<p>I have developed frelatage to be highly configurable, so it is possible to change several constants through environment variables:</p>
<table>
<thead>
<tr>
<th>ENV Variable</th>
<th>Description</th>
<th>Possible Values</th>
<th>Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FRELATAGE_DICTIONARY_ENABLE</strong></td>
<td>Enable the use of mutations based on dictionary elements</td>
<td><code>1</code> to enable, <code>0</code> otherwise</td>
<td><code>1</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_TIMEOUT_DELAY</strong></td>
<td>Delay in seconds after which a function will return a TimeoutError</td>
<td><code>1</code> - <code>20</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_INPUT_FILE_TMP_DIR</strong></td>
<td>Temporary folder where input files are stored</td>
<td>absolute path to a folder, e.g. <code>/tmp/custom_dir</code></td>
<td><code>/tmp/frelatage</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_INPUT_MAX_LEN</strong></td>
<td>Maximum size of an input variable in bytes</td>
<td><code>4</code> - <code>1000000</code></td>
<td><code>4094</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_MAX_THREADS</strong></td>
<td>Maximum number of simultaneous threads</td>
<td><code>8</code> - <code>50</code></td>
<td><code>8</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_MAX_CYCLES_WITHOUT_NEW_PATHS</strong></td>
<td>Number of cycles without new paths found after which we go to the next stage</td>
<td><code>10</code> - <code>50000</code></td>
<td><code>5000</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_INPUT_DIR</strong></td>
<td>Directory containing the initial input files. It needs to be a relative path (to the path of the fuzzing file)</td>
<td>relative path to a folder, e.g. <code>./in</code></td>
<td><code>./in</code></td>
</tr>
<tr>
<td><strong>FRELATAGE_DICTIONARY_DIR</strong></td>
<td>Default directory for dictionaries. It needs to be a relative path (to the path of the fuzzing file)</td>
<td>relative path to a folder, e.g. <code>./dict</code></td>
<td><code>./dict</code></td>
</tr>
</tbody>
</table>
<p>So we start by configuring our fuzzer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export FRELATAGE_DICTIONARY_ENABLE<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_TIMEOUT_DELAY<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_INPUT_FILE_TMP_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/tmp/frelatage&#34;</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_INPUT_MAX_LEN<span style="color:#f92672">=</span><span style="color:#ae81ff">4096</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_MAX_THREADS<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_MAX_CYCLES_WITHOUT_NEW_PATHS<span style="color:#f92672">=</span><span style="color:#ae81ff">5000</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_INPUT_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./in&#34;</span> <span style="color:#f92672">&amp;&amp;</span>
export FRELATAGE_DICTIONARY_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./dict&#34;</span> <span style="color:#f92672">&amp;&amp;</span>
</code></pre></div><p>Then we launch it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">python3 pillow_fuzzer.py
</code></pre></div><table>
<thead>
<tr>
<th style="text-align:center"><img src="https://i.imgur.com/iCB6kNB.gif#center" alt=""></th>
</tr>
</thead>
</table>
<p>The fuzzing process can take from a few hours to several days, depending on the new paths found by fuzzing during the process.</p>
<h2 id="triaging-the-crashes-reports">Triaging the crashes reports</h2>
<p>now enters the less pleasant part, namely triaging the crashes.</p>
<blockquote>
<p><strong>Crash triage</strong> involves examining each crash discovered by Frelatage to determine whether the crash might be worth investigating further (for security researchers, this typically means determining whether the crash is likely due to a vulnerability) and, if so, what the root cause of the crash is. Reviewing each crash in detail can be very time consuming, especially if the fuzzer has identified dozens or hundreds of crashes. This will probably be the case if you leave Frelatage running for several hours/days.</p>
</blockquote>
<p>Each crash is saved in the output folder (<code>./out</code> by default), in a folder named : <code>id:&lt;crash ID&gt;,err:&lt;error type&gt;,err_file:&lt;error file&gt;,err_pos:&lt;err_pos&gt;</code> Which you can read as follows:</p>
<ul>
<li><em><strong>id</strong></em>: The crash number, <em>e.g. 000001</em></li>
<li><em><strong>err</strong></em>: The type of error triggered, <em>e.g. OSError, AttributeError</em></li>
<li><em><strong>err_file</strong></em>: File in which an error has occurred, <em>e.g: image</em></li>
<li><em><strong>err_pos</strong></em>: Line where an error occurred, <em>e.g. 34</em></li>
</ul>
<p>-&gt; The report directory is in the following form and contains files passed as argument:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">    â”œâ”€â”€ out
    â”‚   â”œâ”€â”€ id:&lt;crash ID&gt;,err:&lt;error type&gt;,err_file:&lt;error file&gt;,err_pos:&lt;err_pos&gt;
    â”‚       â”œâ”€â”€ input
    â”‚       â”œâ”€â”€ 0
    â”‚            â”œâ”€â”€ &lt;inputfile1&gt;
    â”‚       â”œâ”€â”€ ...
    â”‚   â”œâ”€â”€ ...
</code></pre></div><table>
<thead>
<tr>
<th style="text-align:center"><img src="https://i.imgur.com/UynLsqM.png#center" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Examples of reports generated by Frelatage</td>
</tr>
</tbody>
</table>
<h4 id="read-a-report">Read a report</h4>
<p>Inputs passed to a function are serialized using the pickle module before being saved in the <code>&lt;report_folder&gt;/input</code> file. It is therefore necessary to deserialize it to be able to read the contents of the file. This action can be performed with <a href="https://github.com/Rog3rSm1th/Frelatage/blob/main/scripts/read_report.py">this script</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./read_report.py input

<span style="color:#f92672">{</span><span style="color:#e6db74">&#39;input&#39;</span>: <span style="color:#f92672">[{</span><span style="color:#e6db74">&#39;value&#39;</span>: <span style="color:#e6db74">&#39;/tmp/frelatage/0/0/0e8ef3773a13824c42f021c1af856c351effa6a2-2&#39;</span>, <span style="color:#e6db74">&#39;file&#39;</span>: True<span style="color:#f92672">}]}</span>
</code></pre></div><h2 id="upcoming-features">Upcoming features</h2>
<p>Frelatage is still in active development, so what has been written above may (will?) change, as I plan to work on new features to make my fuzzer even more effective.</p>
<p>Here are the features I plan to implement in the next few weeks:</p>
<ul>
<li>Possibility to use different dictionaries for each input</li>
<li>Implementation of a crash triage system</li>
<li>A more colorful interface (who wants to work with dull tools?)</li>
</ul>
<p>To keep up to date with the changes made to Frelatage, the very best way is to look at the <a href="https://github.com/Rog3rSm1th/Frelatage">Github repo</a></p>
<h3 id="thanks-for-reading">Thanks for reading!</h3>
<p>for more informations or suggestions, you can contact me at: <a href="mailto:r0g3r5@protonmail.com">r0g3r5@protonmail.com</a>, or on twitter at <a href="https://twitter.com/Rog3rSm1th">@Rog3rSm1th</a></p>
]]></content>
        </item>
        
        <item>
            <title>My RISC-V development environment for programming and reverse engineering purposes</title>
            <link>https://Rog3rSm1th.github.io/posts/set-up-risc-v-developpement-environment/</link>
            <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
            
            <guid>https://Rog3rSm1th.github.io/posts/set-up-risc-v-developpement-environment/</guid>
            <description>First, what is RISC-V?  RISC-V is an open standard instruction set architecture (ISA) that began as a project at UC-Berkeley in 2010. and is based on established reduced instruction set computer (RISC) principles. Unlike most other ISA designs, RISC-V is provided under open source licenses that do not require fees to use.
 The applications of this new architecture are multiple, here is a non-exhaustive list of examples :</description>
            <content type="html"><![CDATA[<h4 id="first-what-is-risc-v"><strong>First, what is RISC-V?</strong></h4>
<blockquote>
<p>RISC-V is an open standard instruction set architecture (ISA) that began as a project at UC-Berkeley in 2010.  and is based on established reduced instruction set computer (RISC) principles. Unlike most other ISA designs, RISC-V is provided under open source licenses that do not require fees to use.</p>
</blockquote>
<p>The applications of this new architecture are multiple, here is a non-exhaustive list of examples :</p>
<ul>
<li><a href="https://riscv.org/news/2019/08/how-the-european-processor-initiative-is-leveraging-risc-v-for-the-future-of-supercomputing/">The European Union has launched a supercomputer project based on the RISC-V architecture, known as the European Processor Initiative (EPI)</a></li>
<li><a href="https://www.theregister.com/2021/06/08/iscas_2000_riscv_laptops/">The Institute of Software Chinese Academy of Sciences announced in June 2021, that it is planning to build 2,000 RV64GC-based laptops by the end of 2022</a></li>
<li><a href="https://www.cnx-software.com/2018/02/27/greenwaves-gap8-is-a-low-power-risc-v-iot-processor-optimized-for-artificial-intelligence-applications/">A Low Power RISC-V IoT Processor Optimized for Artificial Intelligence Applications</a></li>
<li><a href="https://pandaily.com/alibaba-announces-open-source-risc-v-based-xuantie-series-processors/">Ali-Baba annouces open-source RISC-V based processors</a></li>
</ul>
<p>The increasing presence of this architecture on highly critical installations led me to question the security aspect, thus my future publications on this blog will mainly focus on security in the RISC-V architecture, including RISC-V malwares analysis on linux systems.</p>
<p>Although I will soon invest in a development board to facilitate my research, when I wanted to start tinkering with this architecture I did not have one at my disposal. So I had to set up a development environment on my non-RISC-V machine, and this is the topic of this first publication about RISC-V systems.</p>
<p>I&rsquo;d like to show you the setup I&rsquo;ve built to ease the development of programs in assembly on a RISC-V architecture when you don&rsquo;t have a RISC-V machine at home.</p>
<ol>
<li><a href="#how-i-will-structure-my-setup">How I will structure my setup.</a></li>
<li><a href="#download-a-debian-risc-v-64-bits-image">Download a Debian RISC-V 64 bits image</a></li>
<li><a href="#using-qemu-to-emulate-a-risc-v-machine">Using QEMU to emulate a RISC-V machine</a></li>
<li><a href="#creating-a-shared-directory-between-host-and-guest-machines">Creating a shared directory between host and guest machine</a></li>
<li><a href="#installing-debugging-and-compilation-tools">Installing debugging and compilation tools on my host machine</a>
<ol>
<li><a href="#gdb">GDB</a></li>
<li><a href="#gcc">GCC</a></li>
<li><a href="#radare2">Radare2</a></li>
</ol>
</li>
<li><a href="#demonstration">Demonstration</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#to-go-further">To go further</a></li>
</ol>
<h2 id="how-i-will-structure-my-setup">How I will structure my setup</h2>
<p>I started by mapping out what I was going to need:</p>
<ul>
<li>A Debian 64-bit RISC-V image since it is a linux distribution I know quite well. I could also have decided to work with Fedora since <a href="https://fedoraproject.org/wiki/Architectures/RISC-V">there is a RISC-V version</a> of it.</li>
<li>A folder where I will store all my useful scripts to perform redundant actions (assembly code compilation, setup launch&hellip;)</li>
<li>A shared folder between the host machine, and the guest machine.</li>
<li>A folder where I store the assembly programs I write</li>
</ul>
<p>Here is how I built the directory tree of my project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./RISC-V_Setup
â”œâ”€â”€ image
â”‚   â””â”€â”€ Debian image
â”œâ”€â”€ scripts
â”‚   â””â”€â”€ All the useful scripts <span style="color:#f92672">(</span>run.sh, compile.sh...<span style="color:#f92672">)</span>
â”œâ”€â”€ share
â”‚   â””â”€â”€ Share directory between HOST <span style="color:#f92672">(</span>my computer<span style="color:#f92672">)</span> and GUEST machine <span style="color:#f92672">(</span>RISC-V emulator<span style="color:#f92672">)</span>
â”œâ”€â”€ src
â”‚   â””â”€â”€ Directory where I write RISC-V assembly code
</code></pre></div><h2 id="download-a-debian-risc-v-64-bits-image">Download a Debian RISC-V 64 bits image</h2>
<p>I will create an <code>image</code> directory and download a pre-made RISC-V 64 Debian Image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console">mkdir image
wget https://gitlab.com/api/v4/projects/giomasce%2Fdqib/jobs/artifacts/master/download?job=convert_riscv64-virt&#34; -O ./image/debian-rv64.zip
</code></pre></div><p>We now only have to unzip it in the <code>./image</code> folder.</p>
<blockquote>
<p>The default credentials are <strong>debian:debian</strong> and <strong>root:root</strong></p>
</blockquote>
<h2 id="using-qemu-to-emulate-a-risc-v-machine">Using QEMU to emulate a RISC-V machine</h2>
<blockquote>
<p>A small point of vocabulary to avoid confusion: hereafter we will call my main machine the <strong>host</strong> machine and the RISC-V machine emulated with QEMU the <strong>guest</strong> machine.</p>
</blockquote>
<p>-&gt; We emulate a 64 bits version of the RISC-V processor using <a href="https://www.qemu.org/">QEMU</a>. In order to do this we will need the package <code>qemu-system-riscv64</code> which you can install with <code>sudo apt-get install qemu-system-riscv64</code></p>
<blockquote>
<p>For the purpose of this demonstration, we will use a 64-bit version of the RISC-V architecture, but it is however possible to emulate a 32-bit RISC-V processor with QEMU using the <code>qemu-system-riscv32</code> package</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">qemu-system-riscv64 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -machine virt <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -cpu rv64 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -m 1G <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -device virtio-net-device,netdev<span style="color:#f92672">=</span>net <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -netdev user,id<span style="color:#f92672">=</span>net,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -device virtio-blk-device,drive<span style="color:#f92672">=</span>hd <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./Image/artifacts/overlay.qcow2,if<span style="color:#f92672">=</span>none,id<span style="color:#f92672">=</span>hd <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -bios /usr/lib/riscv64-linux-gnu/opensbi/generic/fw_jump.elf <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -kernel /usr/lib/u-boot/qemu-riscv64_smode/uboot.elf <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -append <span style="color:#e6db74">&#34;root=LABEL=rootfs console=ttyS0&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -nographic <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -fsdev local,security_model<span style="color:#f92672">=</span>passthrough,id<span style="color:#f92672">=</span>fsdev0,path<span style="color:#f92672">=</span>./share <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -device virtio-9p-pci,id<span style="color:#f92672">=</span>fs0,fsdev<span style="color:#f92672">=</span>fsdev0,mount_tag<span style="color:#f92672">=</span>hostshare
</code></pre></div><p>I think you may need some further explanation of this script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-cpu rv64
</code></pre></div><p>-&gt; We select a RISC-v 64 bits CPU</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-m 1G
</code></pre></div><p>-&gt; We allocate 1GB of RAM to the guest machine.</p>
<blockquote>
<p>This value depends on your needs and the amount of RAM you are able to allocate to the guest machine.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-netdev user,id<span style="color:#f92672">=</span>net,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22:
</code></pre></div><p>-&gt; This line makes port 22 accessible as localhost:2222. This lets us forward SSH connections.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-bios /usr/lib/riscv64-linux-gnu/opensbi/generic/fw_jump.elf <span style="color:#ae81ff">\
</span></code></pre></div><p>-&gt; If needed, replace with the location of your OpenBSI. But make sure itâ€™s the same configuration.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-append <span style="color:#e6db74">&#34;root=LABEL=rootfs console=ttyS0&#34;</span> <span style="color:#ae81ff">\
</span></code></pre></div><p>-&gt; The append line adds extra options to the kernel command line in UNIX derivatives.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-kernel /usr/lib/u-boot/qemu-riscv64_smode/uboot.elf <span style="color:#ae81ff">\
</span></code></pre></div><p>-&gt; the path of my U-Boot image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-nographic
</code></pre></div><p>-&gt; With this option, you can totally disable graphical output so that QEMU is a simple command line application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> -fsdev local,security_model<span style="color:#f92672">=</span>passthrough,id<span style="color:#f92672">=</span>fsdev0,path<span style="color:#f92672">=</span>./share <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span> -device virtio-9p-pci,id<span style="color:#f92672">=</span>fs0,fsdev<span style="color:#f92672">=</span>fsdev0,mount_tag<span style="color:#f92672">=</span>hostshare
</code></pre></div><p>-&gt; These two lines allow us to create a common folder between the host machine and the guest machine.</p>
<h2 id="creating-a-shared-directory-between-host-and-guest-machines">Creating a shared directory between Host and Guest machines</h2>
<p>I have seen some people choosing to use <code>scp</code> to communicate between their host machine and their guest machine. I propose a different method by using a shared folder between the two machines.</p>
<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'center'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
flowchart TB
    subgraph RISC-V Setup
    Host-Machine--> |./share| Share-directory
    Guest-Machine--> |/mnt/share|Share-directory
    end

  </div>
<p>-&gt; We run this script on the guest machine</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">SHARED_FOLDER<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/mnt/share&#34;</span>

<span style="color:#75715e">#  Create shared folder</span>
mkdir <span style="color:#e6db74">${</span>SHARED_FOLDER<span style="color:#e6db74">}</span>
mount -t 9p -o trans<span style="color:#f92672">=</span>virtio,version<span style="color:#f92672">=</span>9p2000.L hostshare <span style="color:#e6db74">${</span>SHARED_FOLDER<span style="color:#e6db74">}</span>
</code></pre></div><p>Now the contents of <code>./share</code> on the host machine and <code>/mnt/share</code> on the guest machine will be the same</p>
<h2 id="installing-debugging-and-compilation-tools">Installing debugging and compilation tools</h2>
<p>for reverse engineering purposes, I sometimes need a debugger to analyze the behavior of a binary. I am familiar with <strong>GDB</strong> and <strong>Radare2</strong>, and I will show you how to use them in this case.</p>
<p>We will start by installing RISC-V GNU toolchain as it contains a <strong>compiler</strong> (GCC) and our favorite <strong>debugger</strong> (GDB), as well as other very useful tools, such as an <strong>assembler</strong> and a <strong>linker</strong>. Installation instructions can be found <a href="https://github.com/riscv-collab/riscv-gnu-toolchain">here</a></p>
<h4 id="gdb">GDB</h4>
<p>We can now debug a RISC-V binary with the command :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ~ riscv64-unknown-elf-gdb binary
</code></pre></div><h4 id="gcc">GCC</h4>
<p>If you want to compile a binary with gcc for the RISC-V architecture, here is the command to use</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ~ riscv64-unknown-elf-gcc -ggdb -static -o binary binary.c
</code></pre></div><h4 id="radare2">Radare2</h4>
<p><a href="https://github.com/radareorg/radare2">Radare2</a> is pretty cool when it comes to working with RISC-V binaries since <strong>it has built-in RISC-V support</strong>.</p>
<p>You can analyze a binary simply by running it as usual :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ~ r2 ./riscv-binary
</code></pre></div><h2 id="demonstration">Demonstration</h2>
<p>-&gt; Here is a quick reminder of how my setup is organized. :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./RISC-V_Setup
â”œâ”€â”€ share
â”‚   â””â”€â”€ Shared directory between HOST <span style="color:#f92672">(</span>my computer<span style="color:#f92672">)</span> and GUEST machine <span style="color:#f92672">(</span>RISC-V emulator<span style="color:#f92672">)</span>
â”œâ”€â”€ src
â”‚   â””â”€â”€ Directory where I write RISC-V assembly code
â”œâ”€â”€ ...
â”‚   â””â”€â”€ ...
</code></pre></div><p>So we will write our assembly code in the <code>./src</code> folder, and compile it into the <code>./share</code> folder to be able to access it from the guest machine. To do this we will first open a file <code>program.s</code>  which will be a basic RISC-V assembler program that displays a &ldquo;Hello world&rdquo; message on the standard output (We must start somewhere :D ) :</p>
<pre tabindex="0"><code class="language-risc-v" data-lang="risc-v">#
# Risc-V Assembler program to print &quot;Hello World!&quot;
# to stdout.
#
# a0-a2 - parameters to linux function services
# a7 - linux function number
#

.global _start      # Provide program starting address to linker

# Setup the parameters to print hello world
# and then call Linux to do it.

_start: addi  a0, x0, 1      # 1 = StdOut
        la    a1, helloworld # load address of helloworld
        addi  a2, x0, 13     # length of our string
        addi  a7, x0, 64     # linux write system call
        ecall                # Call linux to output the string

# Setup the parameters to exit the program
# and then call Linux to do it.

        addi    a0, x0, 0   # Use 0 return code
        addi    a7, x0, 93  # Service command code 93 terminates
        ecall               # Call linux to terminate the program

.data
helloworld:      .ascii &quot;Hello World!\n&quot;
</code></pre><p>Next we will have to compile this code for a 64-bit RISC-V architecture from our host machine. For this we will use several tools contained in the RISC-V GNU Compiler Toolchain.</p>
<ul>
<li>We use <code>riscv64-linux-gnu-as</code> to assemble the program.</li>
<li><code>riscv64-linux-gnu-ld</code> to link the object file into an executable file.</li>
</ul>
<p>I wrote a bash script (stored in <code>./script</code>) to automatically do the job:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
ASSEMBLY_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dirname $0<span style="color:#66d9ef">)</span><span style="color:#e6db74">/../src&#34;</span>
SHARE_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dirname $0<span style="color:#66d9ef">)</span><span style="color:#e6db74">/../share&#34;</span>

riscv64-linux-gnu-as -march<span style="color:#f92672">=</span>rv64imac -o <span style="color:#e6db74">${</span>SHARE_DIR<span style="color:#e6db74">}</span>/program.o <span style="color:#e6db74">${</span>ASSEMBLY_DIR<span style="color:#e6db74">}</span>/program.s
riscv64-linux-gnu-ld -o <span style="color:#e6db74">${</span>SHARE_DIR<span style="color:#e6db74">}</span>/program <span style="color:#e6db74">${</span>SHARE_DIR<span style="color:#e6db74">}</span>/program.o
rm <span style="color:#e6db74">${</span>SHARE_DIR<span style="color:#e6db74">}</span>/program.o
chmod +x <span style="color:#e6db74">${</span>SHARE_DIR<span style="color:#e6db74">}</span>/program
</code></pre></div><p>We launch it :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ~ ./scripts/compile.sh
</code></pre></div><p>We now have an executable binary named <code>program</code> in <code>/mnt/share</code> on the guest machine.</p>
<p>-&gt; We can test if it works :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">debian@debian:/mnt/share$ ./program
Hello World!
</code></pre></div><p>and it&rsquo;s working!</p>
<p>We can now debug the binary on the host machine with <code>riscv64-unknown-elf-gdb</code> or with <code>Radare2</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So here is a setup I made to be able to work more easily under a RISC-V architecture in a linux environment. My goal was to facilitate the task of those who would like to develop in RISC-V assembler without being able to get a RISC-V machine, or to do reverse engineering. To do so, I published my complete setup with installation instructions <a href="https://github.com/Rog3rSm1th/RISC-V-Setup">here</a>.</p>
<p>If you have any question or corrections to suggest for this article, I can be reached by mail at the following address: <a href="mailto:r0g3r5@protonmail.Com">r0g3r5@protonmail.Com</a></p>
<p>You can also follow me on Twitter (even if I am very (very) little active) : <a href="https://twitter.com/Rog3rSm1th">@Rog3rSm1th</a></p>
<p>I hope I helped you, or taught you something :D</p>
<p><img src="https://i.imgur.com/Bc59GDu.jpg#center" alt=""></p>
<h2 id="to-go-further">To go further</h2>
<ul>
<li><a href="https://medium.com/swlh/risc-v-assembly-for-beginners-387c6cd02c49">A good introduction to RISC-V assembly programming from Eric Engheim</a></li>
<li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer&rsquo;s Manual</a></li>
<li><a href="https://danielmangum.com/posts/risc-v-bytes-qemu-gdb/">Debugging a RISC-V Binary from Daniel Mangun</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Exploit a binary with SigReturn Oriented Programming (SROP)</title>
            <link>https://Rog3rSm1th.github.io/posts/sigreturn-oriented-programming/</link>
            <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
            
            <guid>https://Rog3rSm1th.github.io/posts/sigreturn-oriented-programming/</guid>
            <description>I wrote this article in order to synthesize the different methods I have encountered to exploit a binary with SROP, it is also a preparatory work for the development of a tool allowing to automatically search in a binary the elements useful to the creation of a SROP exploit.
 Since its first presentation at the 35th Security and Privacy IEEE conference in 2014, the SROP method has been the subject of several papers, as well as numerous CTF challenges, however, it remains difficult to find a comprehensive paper on this topic, so this will be the focus of this article.</description>
            <content type="html"><![CDATA[<blockquote>
<p><em>I wrote this article in order to synthesize the different methods I have encountered to exploit a binary with SROP, it is also a preparatory work for the development of a tool allowing to automatically search in a binary the elements useful to the creation of a SROP exploit.</em></p>
</blockquote>
<p>Since its first presentation at the 35th <em>Security and Privacy IEEE conference</em> in 2014, the <em>SROP</em> method has been the subject of several papers, as well as numerous CTF challenges, however, it remains difficult to find a comprehensive paper on this topic, so this will be the focus of this article.</p>
<p>We will cover (probably not exhaustively) the different ways that can be used to exploit a <code>x64/x86</code> binary using the <em>SROP</em> method.</p>
<ol>
<li><a href="#how-does-it-works">How does it works?</a></li>
<li><a href="#why-using-this-technique">Why using this technique?</a></li>
<li><a href="#the-different-ways-to-set-the-eax-register-to-0xf">The different ways to set the eax register to 0xf</a></li>
<li><a href="#exemples-of-custom-sigcontexts">Exemples of custom sigcontexts</a></li>
</ol>
<h2 id="how-does-it-works">How does it works?</h2>
<p>In order to understand how <em>SROP</em> works, we must first understand what happens when a <em>signal</em> occurs in a Unix-like system.</p>
<p>Signals are not the subject of this article, but you can find what you need to understand the following <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">here</a></p>
<h4 id="what-happens-when-a-signal-occurs">What happens when a signal occurs:</h4>
<ul>
<li>the execution of the process will be paused by the <em>kernel</em> in order to jump to a routine that will handle the signal.</li>
<li>In order to safely resume execution after the handler, the context of this process is pushed to be saved on the <em>stack</em> (registers, flags, instruction pointer, stack pointer&hellip;).
the context takes the form of a &ldquo;sigcontext&rdquo; structure whose details can be found <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/uapi/asm/sigcontext.h">here</a></li>
</ul>
<p><img src="https://i.imgur.com/I0R0bJx.png#center" alt=""></p>
<ul>
<li><code>sigreturn()</code> is called once the handler is finished. the process context is restored from the stack and the stack values are removed.</li>
</ul>
<p><img src="https://i.imgur.com/LTzct8J.png#center" alt=""></p>
<p>now that we know all this, we can use this system to exploit a binary.</p>
<p>-&gt; We need three things for a good <em>SROP</em>:</p>
<ul>
<li>First, a <em>buffer overflow</em> vulnerability</li>
<li>A way to put the value <code>0xf</code> into the <code>eax</code> register</li>
<li>a <code>syscall; ret</code> gagdet</li>
</ul>
<h2 id="why-using-this-technique">Why using this technique?</h2>
<ul>
<li>This method allows to build an exploit with a very limited number of gagdets (<em>ROP</em>)</li>
<li>It&rsquo;s much easier to control the execution context (<em>registers</em> status) than with a classical <em>ROP</em></li>
<li><em>SROP</em> exploits are usually portable across different binaries with minimal or no effort and allow easily setting the contents of the <em>registers</em></li>
<li>Because we can ðŸ˜‰</li>
</ul>
<h2 id="the-different-ways-to-set-the-eax-register-to-0xf">The different ways to set the <code>eax</code> register to <code>0xf</code></h2>
<h3 id="the-trivial-case-we-have-a-mov-eax-0xf-gagdet">The trivial case: we have a <code>mov eax, 0xf</code> gagdet</h3>
<p>the case where this gadget is present in the binary is the simplest to exploit, since it will allow us to place <code>0xf</code> into the eax register in a single action, no need to chain <em>ROP gadgets</em>.</p>
<p>âž¡ <strong>Exemple</strong> :</p>
<p>We start by searching the different <em>ROP gadgets</em> present in the binary with the <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> tool</p>
<pre tabindex="0"><code>    $ ~ ROPgadget --binary trivial
    Gadgets information
    ============================================================
    [...]
    0x0000000000001139 : syscall ; ret
    [...]
    0x0000000000001143 : mov eax, 0xf ; ret
    [...]
</code></pre><p>With these two <em>gadgets</em>, building an exploit becomes very simple</p>
<p>Here is the structure of our exploit.</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the  <code>mov eax, 0xf ; ret</code> gadget ( <code>0x0000000000001143</code> )</td>
</tr>
<tr>
<td>address of the  <code>syscall ; ret</code> gadget ( <code>0x0000000000001139</code> )</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h3 id="using-thepop-eax-ret-gadget">Using the<code>pop eax; ret</code> gadget</h3>
<p>This case is a &ldquo;variant&rdquo; of the previous one where it is still rather simple to put the value <code>0xf</code> in the <code>eax</code> register</p>
<p>âž¡ <strong>Exemple</strong> :</p>
<pre tabindex="0"><code>    $ ~ ROPgadget --binary pop_eax
    Gadgets information
    ============================================================
    [...]
    0x000000000040101b : syscall ; ret
    [...]
    0x0000000000401020 : pop eax ; ret
    [...]
</code></pre><p>Here is the structure of our exploit.</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the  <code>pop eax ; ret</code> gadget ( <code>0x0000000000401020</code> )</td>
</tr>
<tr>
<td><code>0xf</code>Â (<em>sigreturn syscall</em> number)</td>
</tr>
<tr>
<td>address of the  <code>syscall ; ret</code> gadget ( <code>0x000000000040101b</code> )</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<p>example of a python exploit by <a href="https://github.com/mishrasunny174">mishrasunny174</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env python2</span>
<span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
context<span style="color:#f92672">.</span>arch <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;amd64&#39;</span>
offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x48</span>
padding <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span>offset
pop_rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0000000000401020</span> <span style="color:#75715e">#pop rax, ret gadget</span>
syscall <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x000000000040101b</span> <span style="color:#75715e">#syscall gadget</span>
bin_sh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0000000000402000</span> <span style="color:#75715e">#bin_sh location in binary</span>
p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./srop&#39;</span>)
payload <span style="color:#f92672">=</span> padding
payload <span style="color:#f92672">+=</span> p64(pop_rax)
payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">15</span>)
payload <span style="color:#f92672">+=</span> p64(syscall)
frame <span style="color:#f92672">=</span> SigreturnFrame()
frame<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>SYS_execve
frame<span style="color:#f92672">.</span>rdi <span style="color:#f92672">=</span> bin_sh
frame<span style="color:#f92672">.</span>rip <span style="color:#f92672">=</span> syscall
payload <span style="color:#f92672">+=</span> str(frame)
p<span style="color:#f92672">.</span>sendline(payload)
p<span style="color:#f92672">.</span>interactive()
</code></pre></div><p>The author of the exploit uses the presence of the string <code>/bin/sh</code> in the binary by passing it as a parameter to the <code>execve</code> function via the <code>rdi</code> register, but it is obviously possible to use many other methods.</p>
<h3 id="use-the-read-syscall-to-set-the-eax-register-to-0xf">Use the <code>read</code> syscall to set the <code>eax</code> register to <code>0xf</code></h3>
<p>An interesting thing to know is that the <code>read</code> syscall records the number of bytes read into the <code>eax</code> register.</p>
<p>There are two methods to set the value <code>0xf</code> in eax using the <code>read</code> syscall:</p>
<h4 id="using-the-mov-eax-0x0-gadget">Using the <code>mov eax, 0x0</code> gadget</h4>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the <code>mov eax, 0x0; ret</code> gadget</td>
</tr>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
</tbody>
</table>
<p>Then we send a <em>15 bytes</em> (<code>0xf</code> -&gt; 15 in decimal) string to the binary, which will allow us to place the value <code>0xf</code> in <code>eax</code></p>
<p>And finally :</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h4 id="using-the-pop-eax-gadget">Using the <code>pop eax</code> gadget</h4>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding until we reach the saved <code>rip</code></td>
</tr>
<tr>
<td>address of the <code>pop eax; ret</code> gadget</td>
</tr>
<tr>
<td><code>0x0</code> (<code>read</code> syscall number)</td>
</tr>
<tr>
<td>address of the <code>syscall; ret</code> gadget</td>
</tr>
</tbody>
</table>
<p>Then we send a 15 bytes string to the binary, which will allow us to place the value <code>0xf</code> in <code>eax</code></p>
<p>And finally :</p>
<table>
<thead>
<tr>
<th><!-- raw HTML omitted --></th>
</tr>
</thead>
<tbody>
<tr>
<td>address of the <code>syscall; ret</code>  gadget</td>
</tr>
<tr>
<td>SigContext structure with the desired parameters</td>
</tr>
</tbody>
</table>
<h2 id="exemples-of-custom-sigcontexts">Exemples of custom sigcontexts</h2>
<p>Once you have figured out how to call the <code>sigreturn</code> syscall, you need to figure out how to get a <strong>shell</strong> through the context that will be restored from the stack.</p>
<h4 id="if-the-binary-contains-the-binsh-string">If the binary contains the <code>/bin/sh</code> string</h4>
<p>The idea is to call the <code>execve</code> function ( syscall <code>0x3b</code> -&gt; 59 in decimal ) with the string <code>/bin/sh</code> as parameter which will give us a shell. The string <code>/bin/sh</code> can either be present in the binary or you can write it in a memory area whose you know the address.</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rip</code></td>
<td><code>syscall</code> instruction address</td>
</tr>
<tr>
<td><code>rax</code></td>
<td><code>0x3b</code> (<code>execve</code> syscall)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td>address of <code>/bin/sh</code></td>
</tr>
<tr>
<td><code>rsi</code></td>
<td><code>0x0</code> (NULL)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td><code>0x0</code> (NULL)</td>
</tr>
</tbody>
</table>
<h4 id="use-mprotect">Use <code>mprotect</code></h4>
<blockquote>
<p><strong>mprotect</strong> : set protection on a region of memory</p>
</blockquote>
<p>We use <code>mprotect</code> to make a memory area of our choice executable and writable to allow <em>shellcode</em> execution at that address. Then we shift the stack to that area so we can easily write data to it. We put in <code>rsp</code> the address containing the entry point of the program to ensure a normal <em>controlflow</em>. We can then arrange to redirect the program to the <em>shellcode</em> address, which will be executed despite the <em>NX protection</em>.</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rax</code></td>
<td><code>0xa</code> (<code>mprotect</code> syscall)</td>
</tr>
<tr>
<td><code>rdi</code></td>
<td>shellcode address</td>
</tr>
<tr>
<td><code>rsi</code></td>
<td>size (<code>0x1000</code> for exemple)</td>
</tr>
<tr>
<td><code>rdx</code></td>
<td><code>0x7</code> -&gt; mode (rwx)</td>
</tr>
<tr>
<td><code>rsp</code></td>
<td>entrypoint (new stack)</td>
</tr>
<tr>
<td><code>rip</code></td>
<td>address of the <code>syscall; ret</code> gadget</td>
</tr>
</tbody>
</table>
<h2 id="to-go-further">To go further</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Sigreturn-oriented_programming">Wikipedia article about SROP</a></li>
<li><a href="https://hackmd.io/@imth/SROP">A write-Up for the Minipwn challenge from the 2019 TheManyHatsClub CTF</a></li>
<li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6956568">Article from Erik Bosman</a></li>
</ul>
<h3 id="thanks-for-reading">Thanks for reading!</h3>
<p>for more informations or suggestions, you can contact me at : <a href="mailto:r0g3r5@protonmail.com">r0g3r5@protonmail.com</a>, or on twitter at <a href="https://twitter.com/Rog3rSm1th">@Rog3rSm1th</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
